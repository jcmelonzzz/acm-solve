## A - 单调栈

#### 题目大意

#### n个数，定义函数f(i)是第i个数后大于它的第一个数下标

#### 单调栈模板题


## B - 发射站

#### 题目大意

#### n个火箭，第i根火箭发射时所散发的能量被两边高于它的所吸收，求最大吸收能量值

#### 单调栈，但有一点值得注意，就是这个题目两边都得注意，而不是只需要关注一边，那就在栈不空的前提下，栈顶元素大于此时的火箭高度，那就栈顶元素加上此时的能量，即可


## C - Po

#### 题目大意

#### 一个长度n的数组，每次操作可以将[l,r]内的所有数加上x，请问从原数组变成目标数组需要多少次（原数组为全0）

#### 利用单调栈，单调递增就添加且次数加1，比栈顶元素小的，就删去栈顶元素，再判断是否与下一个栈顶具有等量关系，然后加次数的时候要注意此时的目标是否为0，为0就不需要变化


## D - Patrik 音乐会的等待

#### 题目大意

#### n个人进去看演唱会，在a和b之间没有比a或b高的则a与b可以看见彼此，计算可以以看见彼此的对数

#### 采用单调栈，但是有一个需要关注的问题就是相等身高的该怎么办，


## E - Graveyard Design

#### 题目大意

#### 皇家墓地一共有n个位置，需要设计若干个正方形来完成设计，一个边长为a的正方形墓地能收纳a*a个位置，请问有多少种方案

#### 最开始的想法是将n开方，然后进行枚举，但是缺陷在于需要多次循环，时间复杂度超标，那么就要考虑优化时间的方法，如何快速定位到我们需要的位置上，设置一个sum的longlong变量储存目前正方形的墓地量，然后对于如何定位，一个区间，逐渐增加，那么就使用双指针，定位一个区间的左右端点，那么思路就出来了，令l=r=初始位置，然后先让r右移，直到sum>=n，这个时候对sum判断，是否需要将l左移，即可（~~由于是poj的题，对于一些细节性的定义很严格，比如longlong和int不能混为一谈，所以错了很多次~~）


## F - pairs 

#### 题目大意

#### 给出n个数，每两个数的差的绝对值小于k的有几对

#### 正常来说两层循环就可以解决但是必然超时，思考一下如何优化时间，一个一个找就会时间超标，那么一堆一堆的找，简化了过程，那么该怎么一堆一堆找，题目也有说这些数在一个坐标轴上，那么一堆也就是一个区间，跟上一道题一样，利用双指针，但是该怎么去求区间里面的答案呢，仔细一想，r右移1个单位，若是r-l<=k，也就是满足条件，那么区间里面的所有数也就是都满足的，增加一个数，那么组合也就增加r-l个，这样子思路就确定了


## G - String

#### 题目大意

#### 有T个案例，每个案例都有一个字符串和一个数k，求至少包含k个不同字母的子字符串有多少个

#### 求子字符串的个数，要求至少k个字符串，那么当有一个子字符串满足条件时，后面的字符加上去也是满足条件的，那么就需要寻找满足条件的子字符串，可以理解为上一道题的坐标轴上，寻找一个区间满足条件，即可，再利用双指针，对字符判断，利用map或者数组进行数值上的转换标记都可


## H - 单词背诵

#### 题目大意

#### 有n个单词要背诵，给出一个有m个单词的文章，输出文章最多要背的单词数和包含这些单词的最短长度

#### 跟上一道题对比，其实就是字符转换成字符串，先对文章进行遍历寻找最多要背的单词数，这个数也就是我们后面需要用到的判断条件，然后长度需要判断，每次循环都需要更新长度，再往下循环，再次更新长度即可，字符串的储存可以用vector和数组，但是vector会有可能mlt~~毕竟用到了map~~


## I - 滑动窗口 /【模板】单调队列

#### 题目大意

#### 一个长度为n的数列，长度为k的窗口搜索最大值和最小值

#### 单调队列的模板题，
```
#include <deque>
deque<int> q;
for(int i=1;i<=c;i++){
    if(!q.empty()&&i - q.front() >= k)q.pop_front();//删除超出范围的数值
    while(!q.empty()&&a[q.back()] < a[i])q.pop_back();
    q.push_back(i);
    printf("%d",a[q.front()]);
    //至于是输出front还是back，都是根据题目来定，包括一些大小于号
}
```


## J - 切蛋糕

#### 题目大意

#### 一个长方体蛋糕分成n块，每块都有不同的幸运值，小Z只能吃m块且需要连续，求最大幸运值

#### 根据样例2，可知不一定需要吃m块，但是最多只能吃m块，最终目的是为了幸运值最大化，那么就利用一下单调队列，求和那么就可以利用前缀和，超出m范围的就删除队首元素，然后对于选进队列的元素，保持单调递增，在选取元素进队列之前先更新最大值即可