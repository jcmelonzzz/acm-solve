## A - Bone Collector

#### 题目大意

#### n个物品，背包体积为v,每个物品都有价值和体积，求价值最大值

#### 之前dp也做过这样的题，这个是01背包问题，没有要求全部装满所以初始化为
```
memset(dp,0,sizeof(dp));
```
#### 然后有一个优化空间复杂度的方法：滚动数组
```
for(int i=1;i<=m;i++{
    for(int j=v;j>=0;j++){
        dp[i][j] = dp[i-1][j];
        if(j >= p[i].m)
            dp[i][j] = max(dp[i][j],dp[i-1][j-p[i].m]+p[i].v);
    }
}
```


## B - 疯狂的采药

#### 题目大意

#### 总共有时间t，草药数目m，每种草药都有对应的价值和采集的时间，求草药价值最大化

#### 首先要求最大值，那么就可以使用dp，然后每件物品所采的数量没有限制，那么就是完全背包问题，初始化为0，dp数组用来表示i时间内能挖多大价值的草药，然后就是状态转移方程
```
dp[j] = max(dp[j],dp[j-p[i].t]+p[i].v);
//由于需要前面的状态来作为此时状态的过渡，所以使用正序遍历
```


## C - 宝物筛选

#### 题目大意

#### n和W，分别表示宝物种数和采集车的最大载重；每种宝物都有对应的价值v,重量w，件数m，求不超载的条件下宝物的最大值

#### 由宝物的条件可知，是多重背包问题，那么dp数组该如何定义，跟上一道差不多，定义为i重量价值最大值，那么按照正常遍历，每种宝物m件，时间复杂度也就是n * W * m，按照这道题的数据范围，必然超时，那么就有两种优化方法，一是二进制，二是单调队列，这里用的是二进制转化法，将m转换成二进制，利用二进制，将m分成i的k次方，简化了选取方法，这样时间复杂度就大大降低
```
for(int i=1;i<=m;i<<=1){
    p[cnt].v = i * a;
    p[cnt++].w = i * b;
    m -= i;
}
if(m > 0){
    p[cnt].v = m*a;
    p[cnt++].w = m*b;
}
```


## D - NASA的食物计划

#### 题目大意

#### h->体积最大值；t->质量最大值；n是物品种类，每个物品都有体积h，质量t，卡路里k，求不超过体积和质量的情况下卡路里最大值

#### 这道题跟最开始的两个区别不大，唯一的区别就是它有两个限制，那么就说明这是二维费用的背包问题，那么就得建立三维dp数组，其他方面差别不大
```
for(int i=1;i<=n;i++){
    for(int j=1;j<=h;j++){
        for(int k=1;k<=t;k++){
            dp[i][j][k] = dp[i-1][j][k];
            if(j >= p[i].h&&k >= p[i].t)dp[i][j][k] = max(dp[i][j][k],dp[i-1][j-p[i].h][k-p[i].t]+p[i].k);
        }
    }
}
```


## E - 通天之分组背包

#### 题目大意

#### 一有n个物品，最大质量m，每个物品都有自己的质量a，价值b，组别c，一组只能选一个，求最大值

#### 首先，物品之间有分组，那就是分组背包，那么dp数组就定义为组别数*质量，先循环组别，再循环质量即可


## F - 金明的预算方案

#### 题目大意

#### 总共有n钱，m个物品，每个物品都有价格、重要度、所属的主件，若主件为0，则它就是主件之一，想要买附件，就必须买所属的主件，求价值最大化

#### 这个就是有依赖的背包的问题，那么思路是什么？最开始就想着先遍历主件，再遍历附件，但是在处理主件之后，无法分清楚主件，也就意味着无法处理附件，那么试着换一下顺序，先遍历附件，再处理主件，dp定义为第i个主件的附件的最大值，这样子就不会出现无法确定主件的问题，接下来就相当于01背包问题，即可


## G - Bone Collector II

#### 题目大意

#### 有n个背包，袋子体积V，第K值，每个背包都有价值和体积，求第k值

#### 第一道就是跟它大差不差的题目，唯一区别就是第一道只是求最大值，这道题~~作妖~~求第k值，~~第一想法就是不会是要排序吧，想想按照dp那令我无法领悟的能力，我觉得巴士~~，想想要怎么去寻找这个答案，如果我们现在找到了k值，接下来找到的比第k值大的就挤进去，比第k值小的就直接排除，那要怎么去排除呢，因为最开始并不知道顺序会是什么样的，那还是乖乖的排序吧，先确定我们要排序的是哪些数据，根据dp可知，大概就是每次遍历的max，加还是不加，利用两个数组储存，然后再进行比较，保留前k个值，

## J - ACboy needs your help

#### 题目大意

#### 有n门课，m天时间，每种课学习多少天都有对应的利润，求最大利润

#### 不超过天数，那么就dp定义为第i天学习可获得的最大利润，然后再定义一个二维数组记录学习利润，首先遍历每一节课，再遍历天数，最后将课的第i天收益遍历，但注意的是我们要逆序遍历天数，查看案例三的推移就可以得知，要是正序会导致一节课上两遍，那就是错误的，所以要逆序