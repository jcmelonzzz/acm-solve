## A - Bone Collector

#### 题目大意

#### n个物品，背包体积为v,每个物品都有价值和体积，求价值最大值

#### 之前dp也做过这样的题，这个是01背包问题，没有要求全部装满所以初始化为
```
memset(dp,0,sizeof(dp));
```
#### 然后有一个优化空间复杂度的方法：滚动数组
```
for(int i=1;i<=m;i++{
    for(int j=v;j>=0;j++){
        dp[i][j] = dp[i-1][j];
        if(j >= p[i].m)
            dp[i][j] = max(dp[i][j],dp[i-1][j-p[i].m]+p[i].v);
    }
}
```


## B - 疯狂的采药

#### 题目大意

#### 总共有时间t，草药数目m，每种草药都有对应的价值和采集的时间，求草药价值最大化

#### 首先要求最大值，那么就可以使用dp，然后又不需要时间刚刚好花完，那么就是01背包问题，初始化为0，dp数组用来表示i时间内能挖多大价值的草药，然后就是状态转移方程
```
dp[j] = max(dp[j],dp[j-p[i].t]+p[i].v);
//由于需要前面的状态来作为此时状态的过渡，所以使用正序遍历
```


## C - 宝物筛选

#### 题目大意

#### n和W，分别表示宝物种数和采集车的最大载重；每种宝物都有对应的价值v,重量w，件数m，求不超载的条件下宝物的最大值

#### 由宝物的条件可知，是多重背包问题，那么dp数组该如何定义，跟上一道差不多，定义为i重量价值最大值，那么按照正常遍历，每种宝物m件，时间复杂度也就是n * W * m，按照这道题的数据范围，必然超时，那么就有两种优化方法，一是二进制，二是单调队列，这里用的是二进制转化法，将m转换成二进制，利用二进制，将m分成i的k次方，简化了选取方法，这样时间复杂度就大大降低
```
for(int i=1;i<=m;i<<=1){
    p[cnt].v = i * a;
    p[cnt++].w = i * b;
    m -= i;
}
if(m > 0){
    p[cnt].v = m*a;
    p[cnt++].w = m*b;
}
```


## D - NASA的食物计划

#### 题目大意

#### h->体积最大值；t->质量最大值；n是物品种类，每个物品都有体积h，质量t，卡路里k，求不超过体积和质量的情况下卡路里最大值

#### 这道题跟最开始的两个区别不大，唯一的区别就是它有两个限制，那么就说明这是二维费用的背包问题，那么就得建立三维dp数组，其他方面差别不大
```
for(int i=1;i<=n;i++){
    for(int j=1;j<=h;j++){
        for(int k=1;k<=t;k++){
            dp[i][j][k] = dp[i-1][j][k];
            if(j >= p[i].h&&k >= p[i].t)dp[i][j][k] = max(dp[i][j][k],dp[i-1][j-p[i].h][k-p[i].t]+p[i].k);
        }
    }
}
```


## E - 通天之分组背包

#### 题目大意

#### 一有n个物品，最大质量m，每个物品都有自己的质量a，价值b，组别c，一组只能选一个，求最大值

#### 首先，物品之间有分组，那就是分组背包，那么dp数组就定义为组别数*质量，先循环组别，再循环质量即可


## J - ACboy needs your help

#### 题目大意

#### 有n门课，m天时间，每种课学习多少天都有对应的利润，求最大利润

#### 不超过天数，那么就dp定义为第i天学习可获得的最大利润，然后再定义一个二维数组记录学习利润，首先遍历每一节课，再遍历天数，最后将课的第i天收益遍历，但注意的是我们要逆序遍历天数，查看案例三的推移就可以得知，要是正序会导致一节课上两遍，那就是错误的，所以要逆序