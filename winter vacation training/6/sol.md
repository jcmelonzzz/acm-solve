## A - Bone Collector

#### 题目大意

#### 有T组案例，其中第一行N，V为物品数量和背包体积，第二行为骨骼的值，第三行为骨骼的体积，求最大值和

#### 寻找最优解，线性dp的问题，而且没有要求装满，那么就是01背包，dp数组的含义即为：i->第i个物品，j->背包体积为j时，再建立一个结构体去储存数据，再利用两层循环来寻找，分别为物品数量和背包体积，当j大于物品体积时，以此作为判断条件
```
if(j >= p[i].m)dp[i][j] = max(dp[i][j],dp[i-1][j-p[i].m]+p[i].v);
```
#### 需要注意的是前面必须先继承上一个物品该体积的最大值
```
for(int j=0;j<=V;j++){
    dp[i][j] = dp[i-1][j];
    solve();
}
```
#### 既然是01，那么就要dp数组初始化为0，然后注意的是体积初始起点是0而不是1（~~毕竟错了好多次这个地方~~）


## B - Common Subsequence

#### 题目大意

#### 两个字符串的最长公共子序列的长度是多少

#### 首先思考dp数组该怎么定义，两个字符串只能通过删除来得到子序列，那么就是通过遍历字符串的每个字，来对比是否相等，再跟前面的对比，所以dp数组定义为二维的，对应两个字符串每个字母的序号，
```
int dp[maxn][maxn];
string a,b;
a = '\0' + a;
b = '\0' + b;
memset(dp,0,sizeof(dp));
int len1 = a.size();
int len2 = b.size();
for(int i=1;i<len1;i++){
    for(int  j=1;j<len2;j++){
        dp[i][j] = max(dp[i-1][j],dp[i][j-1]);//首先跟各少一个字母的情况下去选择最大值
        if(a[i] == b[j])dp[i][j] = max(dp[i][j],dp[i-1][j-1]+1);
    }
}
```


## C - Longest Ordered Subsequence

#### 题目大意

#### 一个长度为n的数组，求最长的子序列，这个子序列满足严格递增

#### 要求最长递增子序列，那么逆推这个过程也就是要知道最后一个值，那么前面的也可以逐渐确定下来，所以dp数组就是对于第i个元素作为最后一个值，通过循环来求解，第一遍循环遍历每个元素，第二遍遍历第i元素前面的元素，dp数组初始化为1，因为每个元素可以独自成为一个子序列
```
int dp[maxn];
int a[maxn];
for(int i=1;i<=n;i++){
    dp[i] = 1;//初始化
    for(int j=1;j<i;j++){
        if(a[j] < a[i])dp[i] = max(dp[i],dp[j]+1);
    }
}
```


## D - 最少拦截系统

#### 有一种特殊的导弹系统，第一天可以无限高度拦截，但后面拦截的高度要比前面的低，求至少需要几套拦截导弹系统

#### 求至少需要多少套系统，那么第一套就得尽可能装下可以拦截的导弹，第二套也接着收剩下的尽可能多的导弹，那么比第一天高的必须由后面的导弹系统来解决，那么本质上跟上一道求上升子序列的一样，那么问题就解决了


## E - 编辑距离

#### 题目大意

#### 两个字符串，可以通过删除、修改、插入来改变，使两个字符串变成一样的，请问至少需要多少次变化

#### 求最少次数，dp依旧定义为二维标记两个字符串的状态，要思考一下三种状态的转移方程
```
dp[i-1][j]+1//删除
dp[i][j-1]+1//插入
dp[i-1][j-1]+1//修改
dp[i-1][j-1]//相等的情况
```
#### 这样子基本上就可以确定思路了，先遍历两个字符串，然后先删除和修改，再判断是否相等即可


## F - 滑雪

#### 一个n*m的区域，然后求最长底滑坡（高度逐渐降低）

#### 首先定义mp[maxn][maxn]来作为地图，因为旁边的区域都可以滑下去（只要高度小于目前即可），那么就使用dfs，来对周围的地区搜索，进而用dp数组来记录，而dp数组又该怎么定义呢，因为有地图数组，那么就跟着地图数组来定义，也就是dp[maxn][maxn],记录每个点的最长路径，那么就是逆向求解
```
for(int i=1;i<=n;i++){
    for(int j=1;j<=m;j++){
        dfs(i,j);
    }
}
```
#### dfs函数定义如下
```
int dfs(int x,int y){
    if(x==y&&x==0)return 0;//超出范围回0
    if(dp[x][y])lreturn dp[x][y];
    dp[x][y] = 1;//初始化自己为一个解
    for(int i=1;i<=4;i++){
        int dx = x + d[i][0];
        int dy = y + d[i][1];
        if(mp[x][y] < mp[dx][dy])dp[x][y] = max(dp[x][y],dfs(dx,dy)+1);
    }
    res = max(res,dp[x][y]);
    return res;
}
```


## G - 饥饿的奶牛

#### 题目大意

#### 有N个区间，每个区间x,y 表示提供的y−x+1堆优质牧草,可以选择任意区间但不能有重复的部分,求能吃多少

#### 最开始思考的就是用dp数组对于第i前能吃多少草，那么每个区间该怎么存放，而且还不能有重复，这个该怎么去避免呢，最开始是想标记一下最后的y，但是会很麻烦，这样子就变成~~一道贪心题了（不是）~~，那么该怎么解决重复区间的问题呢，联系一下第一道题，体积不可能超过，那么当前所定义的j打过当前物体的体积时，那么可以利用
```
dp[j] = max(dp[j],dp[j-v]+m); 
```
#### 可以这样子解决
```
for(int i=0;i<=mx;i++){
    dp[i] = dp[i-1]//继承
    for(int j=0;j<a[i].size();j++){
        dp[i] = max(dp[i],dp[a[i][j]-1]+i-a[i][j]+1);
    }
}
```
#### 区间就可以利用vector来储存，或者开二维数组(~~会MLT~~)即可


## H - Cut Ribbon

#### 题目大意

#### 一根长度为n的钢条，只能分为长度为p，q，r的短条，能分最多多少条（必须恰好裁剪完）

#### dp数组该怎么定义，可以试一试dp[4][maxn];结果就是wa；那么简单一点，直接dp[maxn];三个长度逐一分解
```
int a[4];
int dp[maxn];
memset(dp,0,sizeof(dp));
for(int i=1;i<=3;i++){
    for(int j=0;j<=n;j++){
        if(j>=a[i]&&dp[j-a[i]])dp[j] = max(dp[j],dp[j-a[i]]+1);//为什么要有dp[j-a[i]]存在呢，是因为最开始有说明必须恰好裁剪完
    }
}
```


## I - The Triangle

#### 题目大意

#### 一个n行的数字三角形，每次选择向左下或右下走一格直到阵底，求最大和

#### 从第一行开始走，后面的结果就无法确定，根据DAG图来显化这道题的顺序，就可以发现反向确定更好，先确定底层的状态，再一步一步往上走，便可以解决问题


## J - 合唱队形

#### 题目大意

#### n个同学，选剩下k个同学排序，排序的规则是以t1<t2...<tc>tc+1>...>tk(1<=c<=k)，求k的最大值

#### 一眼看很眼熟，逐渐增高，再逐渐降低，把它们两分开，不就是求上升序列吗？同理，那么定义dp1[maxn],dp2[maxn]分别为左右两边的上升子序列最大长度，最后相加-1（因为自己出现了两次），即可解决答案