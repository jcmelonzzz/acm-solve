## A - 选数

#### 题目大意

#### 有n个数，任选k个数，求其和，若和为素数，则为一个组合，求素数和有几对

#### 选用DFS，从0开始，当a==k时返回，若是没有，那么就对剩下没有遍历到的数进行循环，对和进行判断，即可


## B - 非常可乐

#### 题目大意

#### 一杯S的可乐分成完整的两部分，有两个杯子，分别为N、M，求最少步数

#### 首先~~现在看还是懵的~~，对于可乐分出来，就是倒出来有几种情况，一共六种，然后就是一个一个循环判断，分别加到队列中，接着就是判断是否可以平分，当然s是奇数可以直接判断,


## E - Tempter of the Bone

#### 题目大意

#### 一个n*m的地图，x为墙，s是小狗的起点，d是出口，.是路，要求刚好第T秒到达d，是否可以出去

#### 首先输入时要先确定s的位置，然后进行dfs，可以上下左右，定义一个位移数组，然后对周围进行判断，可以就T++，直到找到d，判断T是否达标，要记住每次走过一个点哦都要标记，走完后要回溯，将标记的点取消掉


## F - 滑雪

#### 一个n*m的区域，然后求最长底滑坡（高度逐渐降低）

#### 首先定义mp[maxn][maxn]来作为地图，因为旁边的区域都可以滑下去（只要高度小于目前即可），那么就使用dfs，来对周围的地区搜索，进而用dp数组来记录，而dp数组又该怎么定义呢，因为有地图数组，那么就跟着地图数组来定义，也就是dp[maxn][maxn],记录每个点的最长路径，那么就是逆向求解
```
for(int i=1;i<=n;i++){
    for(int j=1;j<=m;j++){
        dfs(i,j);
    }
}
```
#### dfs函数定义如下
```
int dfs(int x,int y){
    if(x==y&&x==0)return 0;//超出范围回0
    if(dp[x][y])lreturn dp[x][y];
    dp[x][y] = 1;//初始化自己为一个解
    for(int i=1;i<=4;i++){
        int dx = x + d[i][0];
        int dy = y + d[i][1];
        if(mp[x][y] < mp[dx][dy])dp[x][y] = max(dp[x][y],dfs(dx,dy)+1);
    }
    res = max(res,dp[x][y]);
    return res;
}
```