## A - 并查集

#### 题目大意

#### 完成并查集的查询和合并

#### 模板题


## B - 修复公路

#### 题目大意

#### n个村庄，m条公路，什么时候最早通车，如果通不了，输出-1

#### 显然的并查集的题目，要求输出最早通车的时间，n个村庄至少n-1条公路，从i=n-1开始检索，初始cnt为-1，方便后面的输出，有路的两个村子为一个团伙，引用并查集的知识，就可以ac


## C - 亲戚

#### 题目大意

#### x和y有关系，y和z有关系，那么x和z也有关系，输出是否具有关系

#### 并查集，以一个人为祖宗，检索下来即可


## D - 一中校运会之百米跑

#### 题目大意

#### n个同学，有m组关系，k个老师询问，是否彼此有关系

#### 模板题，唯一区别是要用到字符串，需要注意一些细节，如果用单纯的id数组，无法快速查找字符串所对应的数，这里改用map，但是map如果使用的是<string,int>,很难用find去寻找string对应的数，所以改用<string,string>,直接查找领头人


## E - 朋友

#### 题目大意

#### 小明是1，小红是-1，男女配对，男生是正数，女生是负数

#### 如果用两个数组分别记录男女生的序号，而且女生是负数，略显麻烦，此时利用map，就可以兼顾负数的情况，再利用并查集，即可解决问题


## F - 家谱

#### 题目大意

#### #--父亲，+--儿子，？--询问最老祖宗关系，$文件结束

#### 这个需要提前一个op来判断一下需要进行什么操作，然后对于#，需要注意的是原本是不是作为儿子出场，判断是否是空的（最开始错的原因就是没有判断），然后输出即可。


## G - 合并果子 / [USACO06NOV] Fence Repair G

#### 题目大意

#### n堆果子，通过n-1次剩下一堆，由于搬回去还需要大量力气，所以在合并中尽可能减少力气的损耗，输出最小体力耗费值

#### 每次合并后，要思考这堆新的会不会比后面还重，所以要重新插回去，利用优先队列的自动排序，每次取最前面两个，即最小的两个值，以此求得最小体力耗费。


## H - 世界杯

#### 题目大意

#### 给出各种位置的球员，根据给定的阵容来安排，要求能力值最大化

#### 有四种位置，要是每一种位置都sort，猴年马月才是头，而且记住上一次用过的球员不能再用，那就用优先队列，自动排序外加加完就出去。


## I - 序列合并

#### 题目大意

#### 有两个长度都是N的序列A和B，在A和B中各取一个数相加可以得到N^2个和，求这N^2个和中最小的N个

#### 最开始天真的以为A，B的第一个数最小，加上对面的就可以，忽略了可能A_1可能比B_2大的情况，那该怎么办？就画了一张二维图，要求前N小，那么我就把范围缩小到附近即可，通过二维图可知，在第i * j的位置是第i * j大的数，求前n小，那就i<=sqrt(n);这下子又有个难题，有些数重复计算了，那就将确定的这个三角形范围隔成两个三角形，分开计算，就可以避免重复计算的后果


## J - Cow Dance Show S

#### 题目大意

#### n头奶牛要蹦迪，给一个T_max，演出时间不得超过，每头牛有自己的跳舞时间，舞台一共可以提供k个位置，求不超过时间限制的情况下，k最小值

#### 不超过时间限制，求k的最小值，从只能上台一头牛开始一一枚举，太过损耗时间，优化的方法就是二分，取中间值判断，函数judge该怎么定义，此时舞台可以上mid头奶牛，那就先上mid头，在优先队列里面排序，小的再加上时间，直至牛都上完了，最后回来寻找最大值，如果超过限制就false，然后在main里面用用一个队列储存合格的k（当然没有必要这么做，当时手欠打上去了），记得存储就行

# 总结

#### 这一节所讲的内容涉及并查集和优先队列，对于这两个内容进行模板总结


## 并查集
### 模板

#### find
#### int类型
```
int id[maxn];
int find(int a){
    if(id[a]==a)return id[a];
    return id[a] = find(id[a]);
}
```
#### 简化模板为
```
int find(int a){
    return id[a] == a ? id[a] : id[a] = find(id[a]);
}
```
#### string类型
```
map<string,string> id;
string find(string a){
    if(id[a] == a)return id[a];
    return id[a] = find(id[a]);
}
```
#### Union
```
id[find(a)] = find(b)
```
#### 针对并查集优化，有一篇文章作为指引————[并查集优化](https://www.zhihu.com/question/28410263/answer/40966441)
1.[Path compression](https://zhuanlan.zhihu.com/p/63123489)

## 优先队列
优先队列是c++里面一个特别的数据结构，在头文件<queue>里，特别之处在于我们插入数据后它会自动排序
```
priority_queue<Type, Container, Functional> p;
//type -> 数据类型
//Container -> 容器类型（Container必须是用数组实现的容器，比如vector,deque等等，但不能用 list。STL里面默认用的是vector）
//Functional -> 比较方式//默认大到小

//升序队列
priority_queue <int,vector<int>,greater<int> > p;
//降序队列
priority_queue <int,vector<int>,less<int> >p;
//greater和less是std实现的两个仿函数（就是使一个类的使用看上去像一个函数。其实现就是类中实现一个operator()，这个类就有了类似函数的行为，就是一个仿函数类）

/*以下函数均为对数复杂度*/
p.push();//存放数据
p.pop();//取出栈顶元素
/* 以下函数均为常数复杂度*/
p.top();//询问栈顶元素
p.size();//查询容器中的元素数量
p.empty();//询问容器是否为空
```